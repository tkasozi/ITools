name: Build and Package
on:
#  release:
#   types: [published]
  push:
    branches:
     - 19-prepare-a-pre-release-v0012

env:
  APP_NAME: "ITools"
  CI: True
  DOTNET_VERSION: 9.0
  CMAKE_EXE: "cmake"
  
permissions:
  contents: write

jobs:
  build-and-package:
    runs-on: windows-latest # Or a specific Windows version
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up MSVC environment
        uses: microsoft/setup-msbuild@v2

      - name: Download Inno Setup
        run: |
          Invoke-WebRequest -Uri "https://jrsoftware.org/download.php/is.exe?site=1" -OutFile "inno_setup.exe"
          Start-Process -Wait -FilePath "inno_setup.exe" -ArgumentList "/SILENT"
        shell: powershell

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.8.3'
          target: 'desktop'
          arch: 'win64_msvc2022_64'
          use-official: false
          # Should be set when "use-official" is true
          # email: ${{ secrets.QT_EMAIL }}
          # pw: ${{ secrets.QT_PW }}
      - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Find nethost.dll for .NET 9.0
        id: find_nethost # Give an ID to this step so we can reference its output
        run: |
          echo "Searching for nethost.dll under DOTNET_ROOT: ${{ env.DOTNET_ROOT }}"
          # The nethost.dll is usually in a subdirectory like host/fxr/<some_version_number>/
          # The <some_version_number> will correspond to the hostfxr version, which is tied to the runtime.
          # For .NET 9.0, we expect this version to start with '9.0.'
          
          # For Linux and macOS runners (bash):
          if [[ "$RUNNER_OS" == "Linux" || "$RUNNER_OS" == "macOS" ]]; then
            NETHOST_PATH=$(find "${{ env.DOTNET_ROOT }}" -type f -name "nethost.dll" -path "*/host/fxr/9.0.*/nethost.dll" | head -n 1)
          fi
          
          # For Windows runners (PowerShell):
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            # PowerShell syntax for finding the file
            # Note: Adjust wildcard for version path if necessary
            $nethost_files = Get-ChildItem -Path "${{ env.DOTNET_ROOT }}" -Filter "nethost.dll" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.FullName -like "*\host\fxr\9.0.*\nethost.dll" }
            if ($nethost_files) {
              $NETHOST_PATH = $nethost_files[0].FullName
            } else {
              $NETHOST_PATH = ""
            }
          fi
          
          if [[ -n "$NETHOST_PATH" ]]; then
            echo "Found nethost.dll at: $NETHOST_PATH"
            echo "nethost_path=$NETHOST_PATH" >> $GITHUB_OUTPUT
          else
            echo "nethost.dll for .NET 9.0.x host/fxr not found under ${{ env.DOTNET_ROOT }} with the specified pattern."
            echo "Please check the 'dotnet --info' output and adjust the search path if needed."
            # Optionally, you might want to fail the step if it's critical to find this file
            # exit 1 
          fi
        shell: bash # Ensures bash is used for cross-platform consistency in the if/then logic, even on Windows for the overall script structure

      - name: Build Managed project
        id: dotnet-project
        run: ./ManagedLibrary/build.sh
        shell: bash

      - name: Build project
        run: ./build.sh --clean
        env:
          CMAKE_DOTNET_TARGET_FRAMEWORK: ${env.DOTNET_ROOT}
        shell: bash

      - name: Logging
        run: |
          echo "**********2***************"
          Get-ChildItem "build" -R
          echo "**********2***************"

        shell: powershell

      - name: Find application executable
        id: find-exe
        run: |
          Get-ChildItem -Path "${{ github.workspace }}/build" -Filter "*.exe" | Select-Object -First 1 -ExpandProperty Name | Out-File -FilePath app_exe_name.txt
        shell: powershell

      - name: Read application executable name
        id: app-name
        run: echo "APP_NAME=$(cat app_exe_name.txt)" >> $GITHUB_ENV

      - name: Generate installer with Inno Setup
        run: |
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" ${{ github.workspace }}/it-tools.iss
        env:
          APP_VERSION: ${{ github.event.release.tag_name }} # Assuming your release tag follows a versioning scheme
          OUTPUT_DIR: ${{ github.workspace }}/Output
          APP_BINARY: ${{ github.workspace }}/build/${{ secrets.APP_NAME }}
        shell: powershell

      - name: Create release archive
        uses: thedoctor0/zip-release@master
        with:
          filename: ${{ env.APP_NAME }}-${{ github.event.release.tag_name }}-${{ runner.os }}.zip
          directory: ${{ github.workspace }}/Output

      - name: Upload release asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ${{ github.workspace }}/OUTPUT/${{ env.APP_NAME }}-${{ github.event.release.tag_name }}-${{ runner.os }}.zip
          asset_name: ${{ env.APP_NAME }}-${{ github.event.release.tag_name }}-${{ runner.os }}.zip
          asset_content_type: application/zip
